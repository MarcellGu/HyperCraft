[
  {
    "id": "68a69ffa8ad09ea361f47163",
    "type": "proposal",
    "proposal": {
      "content": {
        "thought": "",
        "answered": true,
        "reasoning_content": ""
      }
    }
  },
  {
    "id": "68a69ffd8ad09ea361f4717b",
    "type": "plan_item",
    "plan_item": {
      "id": "68a69ffd8ad09ea361f4717b",
      "thought": "# 在 Next.js 项目中实现 Markdown 和 KaTeX 渲染\n\n根据您的要求，以下是将 OpenWebUI 中 Markdown 和 KaTeX 渲染功能集成到 Next.js 项目中的详细指南。\n\n## 1. 技术栈\n\n- **Next.js**: React 框架，用于构建全栈 Web 应用。\n- **Marked**: 用于解析 Markdown 文本的库。\n- **KaTeX**: 用于渲染数学公式的库。\n- **CSS Modules / Tailwind CSS / Styled Components** (可选): 用于样式管理。\n\n## 2. 核心组件结构\n\n在 Next.js 项目中，您可以创建以下组件结构：\n\n```\ncomponents/\n├── MarkdownRenderer/\n│   ├── MarkdownRenderer.tsx\n│   ├── MarkdownTokens.tsx\n│   ├── MarkdownInlineTokens.tsx\n│   ├── KatexRenderer.tsx\n│   └── katex-extension.ts\n```\n\n## 3. 实现步骤\n\n### 3.1. 安装依赖\n\n首先，安装必要的依赖项：\n\n```bash\nnpm install marked katex\n```\n\n### 3.2. 创建 KaTeX 扩展\n\n创建 `katex-extension.ts` 文件，定义用于解析 Markdown 中数学公式的 Marked 扩展：\n\n```typescript\nimport katex from 'katex';\n\n// 定义支持的数学分隔符\nconst inlineDelimiters = [\n  { left: '$$', right: '$$', display: true },\n  { left: '$', right: '$', display: false },\n  { left: '\\\\(', right: '\\\\)', display: false },\n];\n\nconst blockDelimiters = [\n  { left: '$$', right: '$$', display: true },\n  { left: '\\\\[', right: '\\\\]', display: true },\n  { left: '\\\\begin{equation}', right: '\\\\end{equation}', display: true },\n  { left: '\\\\begin{align}', right: '\\\\end{align}', display: true },\n  { left: '\\\\begin{gather}', right: '\\\\end{gather}', display: true },\n  { left: '\\\\begin{CD}', right: '\\\\end{CD}', display: true },\n];\n\n// 定义内联 KaTeX 扩展\nconst inlineKatex = {\n  name: 'inlineKatex',\n  level: 'inline',\n  start(src: string) {\n    for (const { left } of inlineDelimiters) {\n      const index = src.indexOf(left);\n      if (index !== -1) {\n        return index;\n      }\n    }\n    return -1; // 没有找到\n  },\n  tokenizer(src: string) {\n    for (const { left, right, display } of inlineDelimiters) {\n      if (src.startsWith(left)) {\n        const endIdx = src.indexOf(right, left.length);\n        if (endIdx !== -1) {\n          return {\n            type: 'inlineKatex',\n            raw: src.slice(0, endIdx + right.length),\n            text: src.slice(left.length, endIdx),\n            display,\n          };\n        }\n      }\n    }\n    return undefined; // 没有匹配\n  },\n  renderer(token: any) {\n    return `\\n`;\n  },\n};\n\n// 定义块级 KaTeX 扩展\nconst blockKatex = {\n  name: 'blockKatex',\n  level: 'block',\n  start(src: string) {\n    for (const { left } of blockDelimiters) {\n      const index = src.indexOf(left);\n      if (index !== -1) {\n        return index;\n      }\n    }\n    return -1; // 没有找到\n  },\n  tokenizer(src: string) {\n    for (const { left, right, display } of blockDelimiters) {\n      if (src.startsWith(left)) {\n        const endIdx = src.indexOf(right, left.length);\n        if (endIdx !== -1) {\n          return {\n            type: 'blockKatex',\n            raw: src.slice(0, endIdx + right.length),\n            text: src.slice(left.length, endIdx),\n            display,\n          };\n        }\n      }\n    }\n    return undefined; // 没有匹配\n  },\n  renderer(token: any) {\n    return `\\n`;\n  },\n};\n\nexport { inlineKatex, blockKatex };\n```\n\n### 3.3. 创建 KaTeX 渲染器\n\n创建 `KatexRenderer.tsx` 文件，用于渲染解析后的数学公式：\n\n```tsx\nimport React, { useEffect, useRef } from 'react';\nimport katex from 'katex';\nimport 'katex/dist/katex.min.css';\n\ninterface KatexRendererProps {\n  content: string;\n  displayMode?: boolean;\n}\n\nconst KatexRenderer: React.FC<KatexRendererProps> = ({ content, displayMode = false }) => {\n  const katexRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (katexRef.current) {\n      try {\n        katex.render(content, katexRef.current, {\n          displayMode,\n          throwOnError: false,\n        });\n      } catch (error) {\n        console.error('KaTeX rendering error:', error);\n        katexRef.current.innerHTML = `<span style=\"color: red;\">Error rendering formula: ${content}</span>`;\n      }\n    }\n  }, [content, displayMode]);\n\n  return <div ref={katexRef} />;\n};\n\nexport default KatexRenderer;\n```\n\n### 3.4. 创建 Markdown 内联 Token 渲染器\n\n创建 `MarkdownInlineTokens.tsx` 文件，用于渲染内联 Markdown 元素：\n\n```tsx\nimport React from 'react';\nimport KatexRenderer from './KatexRenderer';\n\ninterface Token {\n  type: string;\n  raw?: string;\n  href?: string;\n  title?: string;\n  text?: string;\n  tokens?: Token[];\n  display?: boolean;\n}\n\ninterface MarkdownInlineTokensProps {\n  tokens: Token[];\n}\n\nconst MarkdownInlineTokens: React.FC<MarkdownInlineTokensProps> = ({ tokens }) => {\n  return (\n    <>\n      {tokens.map((token, index) => {\n        switch (token.type) {\n          case 'escape':\n          case 'text':\n            return <span key={index}>{token.text}</span>;\n          case 'html':\n            return <span key={index} dangerouslySetInnerHTML={{ __html: token.text || '' }} />;\n          case 'link':\n            return (\n              <a key={index} href={token.href} title={token.title}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </a>\n            );\n          case 'image':\n            return <img key={index} src={token.href} alt={token.text} title={token.title} />;\n          case 'strong':\n            return (\n              <strong key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </strong>\n            );\n          case 'em':\n            return (\n              <em key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </em>\n            );\n          case 'codespan':\n            return <code key={index}>{token.text}</code>;\n          case 'br':\n            return <br key={index} />;\n          case 'del':\n            return (\n              <del key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </del>\n            );\n          case 'inlineKatex':\n            return <KatexRenderer key={index} content={token.text || ''} displayMode={token.display} />;\n          default:\n            return <span key={index}>Unknown inline token: {token.type}</span>;\n        }\n      })}\n    </>\n  );\n};\n\nexport default MarkdownInlineTokens;\n```\n\n### 3.5. 创建 Markdown Token 渲染器\n\n创建 `MarkdownTokens.tsx` 文件，用于渲染块级 Markdown 元素：\n\n```tsx\nimport React from 'react';\nimport MarkdownInlineTokens from './MarkdownInlineTokens';\nimport KatexRenderer from './KatexRenderer';\n\ninterface Token {\n  type: string;\n  raw?: string;\n  text?: string;\n  tokens?: Token[];\n  items?: Token[][];\n  ordered?: boolean;\n  depth?: number;\n  display?: boolean;\n  lang?: string;\n  code?: string;\n}\n\ninterface MarkdownTokensProps {\n  tokens: Token[];\n}\n\nconst MarkdownTokens: React.FC<MarkdownTokensProps> = ({ tokens }) => {\n  return (\n    <>\n      {tokens.map((token, index) => {\n        switch (token.type) {\n          case 'heading':\n            const HeadingTag = `h${token.depth}` as keyof JSX.IntrinsicElements;\n            return (\n              <HeadingTag key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </HeadingTag>\n            );\n          case 'paragraph':\n            return (\n              <p key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </p>\n            );\n          case 'code':\n            return (\n              <pre key={index}>\n                <code className={token.lang ? `language-${token.lang}` : undefined}>\n                  {token.text}\n                </code>\n              </pre>\n            );\n          case 'blockquote':\n            return (\n              <blockquote key={index}>\n                <MarkdownTokens tokens={token.tokens || []} />\n              </blockquote>\n            );\n          case 'list':\n            const ListTag = token.ordered ? 'ol' : 'ul';\n            return (\n              <ListTag key={index}>\n                {token.items?.map((item, itemIndex) => (\n                  <li key={itemIndex}>\n                    <MarkdownTokens tokens={item} />\n                  </li>\n                ))}\n              </ListTag>\n            );\n          case 'inlineKatex':\n            return <KatexRenderer key={index} content={token.text || ''} displayMode={token.display} />;\n          case 'blockKatex':\n            return <KatexRenderer key={index} content={token.text || ''} displayMode={token.display} />;\n          default:\n            return <div key={index}>Unknown block token: {token.type}</div>;\n        }\n      })}\n    </>\n  );\n};\n\nexport default MarkdownTokens;\n```\n\n### 3.6. 创建主 Markdown 渲染器\n\n创建 `MarkdownRenderer.tsx` 文件，作为主入口组件：\n\n```tsx\nimport React, { useEffect, useState } from 'react';\nimport { marked } from 'marked';\nimport { inlineKatex, blockKatex } from './katex-extension';\nimport MarkdownTokens from './MarkdownTokens';\n\ninterface MarkdownRendererProps {\n  content: string;\n}\n\nconst MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ content }) => {\n  const [tokens, setTokens] = useState<marked.Token[]>([]);\n\n  useEffect(() => {\n    // 注册扩展\n    marked.use({ extensions: [inlineKatex, blockKatex] });\n    \n    // 解析 Markdown\n    const parsedTokens = marked.lexer(content);\n    setTokens(parsedTokens);\n  }, [content]);\n\n  return <MarkdownTokens tokens={tokens} />;\n};\n\nexport default MarkdownRenderer;\n```\n\n## 4. 使用示例\n\n在您的 Next.js 页面或组件中使用 `MarkdownRenderer`：\n\n```tsx\nimport React from 'react';\nimport MarkdownRenderer from '../components/MarkdownRenderer/MarkdownRenderer';\n\nconst HomePage: React.FC = () => {\n  const markdownContent = `\n# 欢迎使用 Markdown 和 KaTeX\n\n这是一个段落，包含一个**粗体**文本和一个*斜体*文本。\n\n这是一个内联公式: $E = mc^2$。\n\n这是一个块级公式:\n\n$$\n\\\\int_{0}^{\\\\infty} e^{-x^2} dx = \\\\frac{\\\\sqrt{\\\\pi}}{2}\n$$\n\n- 项目 1\n- 项目 2\n  - 子项目 2.1\n  - 子项目 2.2\n`;\n\n  return (\n    <div>\n      <h1>Markdown 和 KaTeX 示例</h1>\n      <MarkdownRenderer content={markdownContent} />\n    </div>\n  );\n};\n\nexport default HomePage;\n```\n\n## 5. 注意事项\n\n1. **样式**: 确保正确导入 `katex/dist/katex.min.css` 以应用 KaTeX 样式。\n2. **错误处理**: 在 `KatexRenderer` 中添加了基本的错误处理，以防止渲染错误导致整个应用崩溃。\n3. **性能**: 对于大量 Markdown 内容，考虑使用 `React.memo` 或其他优化技术来提高渲染性能。\n4. **扩展性**: 您可以根据需要添加更多 Marked 扩展，例如支持表格、任务列表等。\n\n通过以上步骤，您就可以在 Next.js 项目中成功集成和使用 OpenWebUI 的 Markdown 和 KaTeX 渲染功能。",
      "reasoning_content": "",
      "tool_call_info": {
        "id": "68a69ffd8ad09ea361f4717d",
        "name": "response_to_user",
        "params": {
          "summary": "# 在 Next.js 项目中实现 Markdown 和 KaTeX 渲染\n\n根据您的要求，以下是将 OpenWebUI 中 Markdown 和 KaTeX 渲染功能集成到 Next.js 项目中的详细指南。\n\n## 1. 技术栈\n\n- **Next.js**: React 框架，用于构建全栈 Web 应用。\n- **Marked**: 用于解析 Markdown 文本的库。\n- **KaTeX**: 用于渲染数学公式的库。\n- **CSS Modules / Tailwind CSS / Styled Components** (可选): 用于样式管理。\n\n## 2. 核心组件结构\n\n在 Next.js 项目中，您可以创建以下组件结构：\n\n```\ncomponents/\n├── MarkdownRenderer/\n│   ├── MarkdownRenderer.tsx\n│   ├── MarkdownTokens.tsx\n│   ├── MarkdownInlineTokens.tsx\n│   ├── KatexRenderer.tsx\n│   └── katex-extension.ts\n```\n\n## 3. 实现步骤\n\n### 3.1. 安装依赖\n\n首先，安装必要的依赖项：\n\n```bash\nnpm install marked katex\n```\n\n### 3.2. 创建 KaTeX 扩展\n\n创建 `katex-extension.ts` 文件，定义用于解析 Markdown 中数学公式的 Marked 扩展：\n\n```typescript\nimport katex from 'katex';\n\n// 定义支持的数学分隔符\nconst inlineDelimiters = [\n  { left: '$$', right: '$$', display: true },\n  { left: '$', right: '$', display: false },\n  { left: '\\\\(', right: '\\\\)', display: false },\n];\n\nconst blockDelimiters = [\n  { left: '$$', right: '$$', display: true },\n  { left: '\\\\[', right: '\\\\]', display: true },\n  { left: '\\\\begin{equation}', right: '\\\\end{equation}', display: true },\n  { left: '\\\\begin{align}', right: '\\\\end{align}', display: true },\n  { left: '\\\\begin{gather}', right: '\\\\end{gather}', display: true },\n  { left: '\\\\begin{CD}', right: '\\\\end{CD}', display: true },\n];\n\n// 定义内联 KaTeX 扩展\nconst inlineKatex = {\n  name: 'inlineKatex',\n  level: 'inline',\n  start(src: string) {\n    for (const { left } of inlineDelimiters) {\n      const index = src.indexOf(left);\n      if (index !== -1) {\n        return index;\n      }\n    }\n    return -1; // 没有找到\n  },\n  tokenizer(src: string) {\n    for (const { left, right, display } of inlineDelimiters) {\n      if (src.startsWith(left)) {\n        const endIdx = src.indexOf(right, left.length);\n        if (endIdx !== -1) {\n          return {\n            type: 'inlineKatex',\n            raw: src.slice(0, endIdx + right.length),\n            text: src.slice(left.length, endIdx),\n            display,\n          };\n        }\n      }\n    }\n    return undefined; // 没有匹配\n  },\n  renderer(token: any) {\n    return `\\n`;\n  },\n};\n\n// 定义块级 KaTeX 扩展\nconst blockKatex = {\n  name: 'blockKatex',\n  level: 'block',\n  start(src: string) {\n    for (const { left } of blockDelimiters) {\n      const index = src.indexOf(left);\n      if (index !== -1) {\n        return index;\n      }\n    }\n    return -1; // 没有找到\n  },\n  tokenizer(src: string) {\n    for (const { left, right, display } of blockDelimiters) {\n      if (src.startsWith(left)) {\n        const endIdx = src.indexOf(right, left.length);\n        if (endIdx !== -1) {\n          return {\n            type: 'blockKatex',\n            raw: src.slice(0, endIdx + right.length),\n            text: src.slice(left.length, endIdx),\n            display,\n          };\n        }\n      }\n    }\n    return undefined; // 没有匹配\n  },\n  renderer(token: any) {\n    return `\\n`;\n  },\n};\n\nexport { inlineKatex, blockKatex };\n```\n\n### 3.3. 创建 KaTeX 渲染器\n\n创建 `KatexRenderer.tsx` 文件，用于渲染解析后的数学公式：\n\n```tsx\nimport React, { useEffect, useRef } from 'react';\nimport katex from 'katex';\nimport 'katex/dist/katex.min.css';\n\ninterface KatexRendererProps {\n  content: string;\n  displayMode?: boolean;\n}\n\nconst KatexRenderer: React.FC<KatexRendererProps> = ({ content, displayMode = false }) => {\n  const katexRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (katexRef.current) {\n      try {\n        katex.render(content, katexRef.current, {\n          displayMode,\n          throwOnError: false,\n        });\n      } catch (error) {\n        console.error('KaTeX rendering error:', error);\n        katexRef.current.innerHTML = `<span style=\"color: red;\">Error rendering formula: ${content}</span>`;\n      }\n    }\n  }, [content, displayMode]);\n\n  return <div ref={katexRef} />;\n};\n\nexport default KatexRenderer;\n```\n\n### 3.4. 创建 Markdown 内联 Token 渲染器\n\n创建 `MarkdownInlineTokens.tsx` 文件，用于渲染内联 Markdown 元素：\n\n```tsx\nimport React from 'react';\nimport KatexRenderer from './KatexRenderer';\n\ninterface Token {\n  type: string;\n  raw?: string;\n  href?: string;\n  title?: string;\n  text?: string;\n  tokens?: Token[];\n  display?: boolean;\n}\n\ninterface MarkdownInlineTokensProps {\n  tokens: Token[];\n}\n\nconst MarkdownInlineTokens: React.FC<MarkdownInlineTokensProps> = ({ tokens }) => {\n  return (\n    <>\n      {tokens.map((token, index) => {\n        switch (token.type) {\n          case 'escape':\n          case 'text':\n            return <span key={index}>{token.text}</span>;\n          case 'html':\n            return <span key={index} dangerouslySetInnerHTML={{ __html: token.text || '' }} />;\n          case 'link':\n            return (\n              <a key={index} href={token.href} title={token.title}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </a>\n            );\n          case 'image':\n            return <img key={index} src={token.href} alt={token.text} title={token.title} />;\n          case 'strong':\n            return (\n              <strong key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </strong>\n            );\n          case 'em':\n            return (\n              <em key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </em>\n            );\n          case 'codespan':\n            return <code key={index}>{token.text}</code>;\n          case 'br':\n            return <br key={index} />;\n          case 'del':\n            return (\n              <del key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </del>\n            );\n          case 'inlineKatex':\n            return <KatexRenderer key={index} content={token.text || ''} displayMode={token.display} />;\n          default:\n            return <span key={index}>Unknown inline token: {token.type}</span>;\n        }\n      })}\n    </>\n  );\n};\n\nexport default MarkdownInlineTokens;\n```\n\n### 3.5. 创建 Markdown Token 渲染器\n\n创建 `MarkdownTokens.tsx` 文件，用于渲染块级 Markdown 元素：\n\n```tsx\nimport React from 'react';\nimport MarkdownInlineTokens from './MarkdownInlineTokens';\nimport KatexRenderer from './KatexRenderer';\n\ninterface Token {\n  type: string;\n  raw?: string;\n  text?: string;\n  tokens?: Token[];\n  items?: Token[][];\n  ordered?: boolean;\n  depth?: number;\n  display?: boolean;\n  lang?: string;\n  code?: string;\n}\n\ninterface MarkdownTokensProps {\n  tokens: Token[];\n}\n\nconst MarkdownTokens: React.FC<MarkdownTokensProps> = ({ tokens }) => {\n  return (\n    <>\n      {tokens.map((token, index) => {\n        switch (token.type) {\n          case 'heading':\n            const HeadingTag = `h${token.depth}` as keyof JSX.IntrinsicElements;\n            return (\n              <HeadingTag key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </HeadingTag>\n            );\n          case 'paragraph':\n            return (\n              <p key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </p>\n            );\n          case 'code':\n            return (\n              <pre key={index}>\n                <code className={token.lang ? `language-${token.lang}` : undefined}>\n                  {token.text}\n                </code>\n              </pre>\n            );\n          case 'blockquote':\n            return (\n              <blockquote key={index}>\n                <MarkdownTokens tokens={token.tokens || []} />\n              </blockquote>\n            );\n          case 'list':\n            const ListTag = token.ordered ? 'ol' : 'ul';\n            return (\n              <ListTag key={index}>\n                {token.items?.map((item, itemIndex) => (\n                  <li key={itemIndex}>\n                    <MarkdownTokens tokens={item} />\n                  </li>\n                ))}\n              </ListTag>\n            );\n          case 'inlineKatex':\n            return <KatexRenderer key={index} content={token.text || ''} displayMode={token.display} />;\n          case 'blockKatex':\n            return <KatexRenderer key={index} content={token.text || ''} displayMode={token.display} />;\n          default:\n            return <div key={index}>Unknown block token: {token.type}</div>;\n        }\n      })}\n    </>\n  );\n};\n\nexport default MarkdownTokens;\n```\n\n### 3.6. 创建主 Markdown 渲染器\n\n创建 `MarkdownRenderer.tsx` 文件，作为主入口组件：\n\n```tsx\nimport React, { useEffect, useState } from 'react';\nimport { marked } from 'marked';\nimport { inlineKatex, blockKatex } from './katex-extension';\nimport MarkdownTokens from './MarkdownTokens';\n\ninterface MarkdownRendererProps {\n  content: string;\n}\n\nconst MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ content }) => {\n  const [tokens, setTokens] = useState<marked.Token[]>([]);\n\n  useEffect(() => {\n    // 注册扩展\n    marked.use({ extensions: [inlineKatex, blockKatex] });\n    \n    // 解析 Markdown\n    const parsedTokens = marked.lexer(content);\n    setTokens(parsedTokens);\n  }, [content]);\n\n  return <MarkdownTokens tokens={tokens} />;\n};\n\nexport default MarkdownRenderer;\n```\n\n## 4. 使用示例\n\n在您的 Next.js 页面或组件中使用 `MarkdownRenderer`：\n\n```tsx\nimport React from 'react';\nimport MarkdownRenderer from '../components/MarkdownRenderer/MarkdownRenderer';\n\nconst HomePage: React.FC = () => {\n  const markdownContent = `\n# 欢迎使用 Markdown 和 KaTeX\n\n这是一个段落，包含一个**粗体**文本和一个*斜体*文本。\n\n这是一个内联公式: $E = mc^2$。\n\n这是一个块级公式:\n\n$$\n\\\\int_{0}^{\\\\infty} e^{-x^2} dx = \\\\frac{\\\\sqrt{\\\\pi}}{2}\n$$\n\n- 项目 1\n- 项目 2\n  - 子项目 2.1\n  - 子项目 2.2\n`;\n\n  return (\n    <div>\n      <h1>Markdown 和 KaTeX 示例</h1>\n      <MarkdownRenderer content={markdownContent} />\n    </div>\n  );\n};\n\nexport default HomePage;\n```\n\n## 5. 注意事项\n\n1. **样式**: 确保正确导入 `katex/dist/katex.min.css` 以应用 KaTeX 样式。\n2. **错误处理**: 在 `KatexRenderer` 中添加了基本的错误处理，以防止渲染错误导致整个应用崩溃。\n3. **性能**: 对于大量 Markdown 内容，考虑使用 `React.memo` 或其他优化技术来提高渲染性能。\n4. **扩展性**: 您可以根据需要添加更多 Marked 扩展，例如支持表格、任务列表等。\n\n通过以上步骤，您就可以在 Next.js 项目中成功集成和使用 OpenWebUI 的 Markdown 和 KaTeX 渲染功能。"
        },
        "result": {
          "status": "success",
          "error_message": "",
          "data": {
            "summary": "# 在 Next.js 项目中实现 Markdown 和 KaTeX 渲染\n\n根据您的要求，以下是将 OpenWebUI 中 Markdown 和 KaTeX 渲染功能集成到 Next.js 项目中的详细指南。\n\n## 1. 技术栈\n\n- **Next.js**: React 框架，用于构建全栈 Web 应用。\n- **Marked**: 用于解析 Markdown 文本的库。\n- **KaTeX**: 用于渲染数学公式的库。\n- **CSS Modules / Tailwind CSS / Styled Components** (可选): 用于样式管理。\n\n## 2. 核心组件结构\n\n在 Next.js 项目中，您可以创建以下组件结构：\n\n```\ncomponents/\n├── MarkdownRenderer/\n│   ├── MarkdownRenderer.tsx\n│   ├── MarkdownTokens.tsx\n│   ├── MarkdownInlineTokens.tsx\n│   ├── KatexRenderer.tsx\n│   └── katex-extension.ts\n```\n\n## 3. 实现步骤\n\n### 3.1. 安装依赖\n\n首先，安装必要的依赖项：\n\n```bash\nnpm install marked katex\n```\n\n### 3.2. 创建 KaTeX 扩展\n\n创建 `katex-extension.ts` 文件，定义用于解析 Markdown 中数学公式的 Marked 扩展：\n\n```typescript\nimport katex from 'katex';\n\n// 定义支持的数学分隔符\nconst inlineDelimiters = [\n  { left: '$$', right: '$$', display: true },\n  { left: '$', right: '$', display: false },\n  { left: '\\\\(', right: '\\\\)', display: false },\n];\n\nconst blockDelimiters = [\n  { left: '$$', right: '$$', display: true },\n  { left: '\\\\[', right: '\\\\]', display: true },\n  { left: '\\\\begin{equation}', right: '\\\\end{equation}', display: true },\n  { left: '\\\\begin{align}', right: '\\\\end{align}', display: true },\n  { left: '\\\\begin{gather}', right: '\\\\end{gather}', display: true },\n  { left: '\\\\begin{CD}', right: '\\\\end{CD}', display: true },\n];\n\n// 定义内联 KaTeX 扩展\nconst inlineKatex = {\n  name: 'inlineKatex',\n  level: 'inline',\n  start(src: string) {\n    for (const { left } of inlineDelimiters) {\n      const index = src.indexOf(left);\n      if (index !== -1) {\n        return index;\n      }\n    }\n    return -1; // 没有找到\n  },\n  tokenizer(src: string) {\n    for (const { left, right, display } of inlineDelimiters) {\n      if (src.startsWith(left)) {\n        const endIdx = src.indexOf(right, left.length);\n        if (endIdx !== -1) {\n          return {\n            type: 'inlineKatex',\n            raw: src.slice(0, endIdx + right.length),\n            text: src.slice(left.length, endIdx),\n            display,\n          };\n        }\n      }\n    }\n    return undefined; // 没有匹配\n  },\n  renderer(token: any) {\n    return `\\n`;\n  },\n};\n\n// 定义块级 KaTeX 扩展\nconst blockKatex = {\n  name: 'blockKatex',\n  level: 'block',\n  start(src: string) {\n    for (const { left } of blockDelimiters) {\n      const index = src.indexOf(left);\n      if (index !== -1) {\n        return index;\n      }\n    }\n    return -1; // 没有找到\n  },\n  tokenizer(src: string) {\n    for (const { left, right, display } of blockDelimiters) {\n      if (src.startsWith(left)) {\n        const endIdx = src.indexOf(right, left.length);\n        if (endIdx !== -1) {\n          return {\n            type: 'blockKatex',\n            raw: src.slice(0, endIdx + right.length),\n            text: src.slice(left.length, endIdx),\n            display,\n          };\n        }\n      }\n    }\n    return undefined; // 没有匹配\n  },\n  renderer(token: any) {\n    return `\\n`;\n  },\n};\n\nexport { inlineKatex, blockKatex };\n```\n\n### 3.3. 创建 KaTeX 渲染器\n\n创建 `KatexRenderer.tsx` 文件，用于渲染解析后的数学公式：\n\n```tsx\nimport React, { useEffect, useRef } from 'react';\nimport katex from 'katex';\nimport 'katex/dist/katex.min.css';\n\ninterface KatexRendererProps {\n  content: string;\n  displayMode?: boolean;\n}\n\nconst KatexRenderer: React.FC<KatexRendererProps> = ({ content, displayMode = false }) => {\n  const katexRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    if (katexRef.current) {\n      try {\n        katex.render(content, katexRef.current, {\n          displayMode,\n          throwOnError: false,\n        });\n      } catch (error) {\n        console.error('KaTeX rendering error:', error);\n        katexRef.current.innerHTML = `<span style=\"color: red;\">Error rendering formula: ${content}</span>`;\n      }\n    }\n  }, [content, displayMode]);\n\n  return <div ref={katexRef} />;\n};\n\nexport default KatexRenderer;\n```\n\n### 3.4. 创建 Markdown 内联 Token 渲染器\n\n创建 `MarkdownInlineTokens.tsx` 文件，用于渲染内联 Markdown 元素：\n\n```tsx\nimport React from 'react';\nimport KatexRenderer from './KatexRenderer';\n\ninterface Token {\n  type: string;\n  raw?: string;\n  href?: string;\n  title?: string;\n  text?: string;\n  tokens?: Token[];\n  display?: boolean;\n}\n\ninterface MarkdownInlineTokensProps {\n  tokens: Token[];\n}\n\nconst MarkdownInlineTokens: React.FC<MarkdownInlineTokensProps> = ({ tokens }) => {\n  return (\n    <>\n      {tokens.map((token, index) => {\n        switch (token.type) {\n          case 'escape':\n          case 'text':\n            return <span key={index}>{token.text}</span>;\n          case 'html':\n            return <span key={index} dangerouslySetInnerHTML={{ __html: token.text || '' }} />;\n          case 'link':\n            return (\n              <a key={index} href={token.href} title={token.title}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </a>\n            );\n          case 'image':\n            return <img key={index} src={token.href} alt={token.text} title={token.title} />;\n          case 'strong':\n            return (\n              <strong key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </strong>\n            );\n          case 'em':\n            return (\n              <em key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </em>\n            );\n          case 'codespan':\n            return <code key={index}>{token.text}</code>;\n          case 'br':\n            return <br key={index} />;\n          case 'del':\n            return (\n              <del key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </del>\n            );\n          case 'inlineKatex':\n            return <KatexRenderer key={index} content={token.text || ''} displayMode={token.display} />;\n          default:\n            return <span key={index}>Unknown inline token: {token.type}</span>;\n        }\n      })}\n    </>\n  );\n};\n\nexport default MarkdownInlineTokens;\n```\n\n### 3.5. 创建 Markdown Token 渲染器\n\n创建 `MarkdownTokens.tsx` 文件，用于渲染块级 Markdown 元素：\n\n```tsx\nimport React from 'react';\nimport MarkdownInlineTokens from './MarkdownInlineTokens';\nimport KatexRenderer from './KatexRenderer';\n\ninterface Token {\n  type: string;\n  raw?: string;\n  text?: string;\n  tokens?: Token[];\n  items?: Token[][];\n  ordered?: boolean;\n  depth?: number;\n  display?: boolean;\n  lang?: string;\n  code?: string;\n}\n\ninterface MarkdownTokensProps {\n  tokens: Token[];\n}\n\nconst MarkdownTokens: React.FC<MarkdownTokensProps> = ({ tokens }) => {\n  return (\n    <>\n      {tokens.map((token, index) => {\n        switch (token.type) {\n          case 'heading':\n            const HeadingTag = `h${token.depth}` as keyof JSX.IntrinsicElements;\n            return (\n              <HeadingTag key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </HeadingTag>\n            );\n          case 'paragraph':\n            return (\n              <p key={index}>\n                <MarkdownInlineTokens tokens={token.tokens || []} />\n              </p>\n            );\n          case 'code':\n            return (\n              <pre key={index}>\n                <code className={token.lang ? `language-${token.lang}` : undefined}>\n                  {token.text}\n                </code>\n              </pre>\n            );\n          case 'blockquote':\n            return (\n              <blockquote key={index}>\n                <MarkdownTokens tokens={token.tokens || []} />\n              </blockquote>\n            );\n          case 'list':\n            const ListTag = token.ordered ? 'ol' : 'ul';\n            return (\n              <ListTag key={index}>\n                {token.items?.map((item, itemIndex) => (\n                  <li key={itemIndex}>\n                    <MarkdownTokens tokens={item} />\n                  </li>\n                ))}\n              </ListTag>\n            );\n          case 'inlineKatex':\n            return <KatexRenderer key={index} content={token.text || ''} displayMode={token.display} />;\n          case 'blockKatex':\n            return <KatexRenderer key={index} content={token.text || ''} displayMode={token.display} />;\n          default:\n            return <div key={index}>Unknown block token: {token.type}</div>;\n        }\n      })}\n    </>\n  );\n};\n\nexport default MarkdownTokens;\n```\n\n### 3.6. 创建主 Markdown 渲染器\n\n创建 `MarkdownRenderer.tsx` 文件，作为主入口组件：\n\n```tsx\nimport React, { useEffect, useState } from 'react';\nimport { marked } from 'marked';\nimport { inlineKatex, blockKatex } from './katex-extension';\nimport MarkdownTokens from './MarkdownTokens';\n\ninterface MarkdownRendererProps {\n  content: string;\n}\n\nconst MarkdownRenderer: React.FC<MarkdownRendererProps> = ({ content }) => {\n  const [tokens, setTokens] = useState<marked.Token[]>([]);\n\n  useEffect(() => {\n    // 注册扩展\n    marked.use({ extensions: [inlineKatex, blockKatex] });\n    \n    // 解析 Markdown\n    const parsedTokens = marked.lexer(content);\n    setTokens(parsedTokens);\n  }, [content]);\n\n  return <MarkdownTokens tokens={tokens} />;\n};\n\nexport default MarkdownRenderer;\n```\n\n## 4. 使用示例\n\n在您的 Next.js 页面或组件中使用 `MarkdownRenderer`：\n\n```tsx\nimport React from 'react';\nimport MarkdownRenderer from '../components/MarkdownRenderer/MarkdownRenderer';\n\nconst HomePage: React.FC = () => {\n  const markdownContent = `\n# 欢迎使用 Markdown 和 KaTeX\n\n这是一个段落，包含一个**粗体**文本和一个*斜体*文本。\n\n这是一个内联公式: $E = mc^2$。\n\n这是一个块级公式:\n\n$$\n\\\\int_{0}^{\\\\infty} e^{-x^2} dx = \\\\frac{\\\\sqrt{\\\\pi}}{2}\n$$\n\n- 项目 1\n- 项目 2\n  - 子项目 2.1\n  - 子项目 2.2\n`;\n\n  return (\n    <div>\n      <h1>Markdown 和 KaTeX 示例</h1>\n      <MarkdownRenderer content={markdownContent} />\n    </div>\n  );\n};\n\nexport default HomePage;\n```\n\n## 5. 注意事项\n\n1. **样式**: 确保正确导入 `katex/dist/katex.min.css` 以应用 KaTeX 样式。\n2. **错误处理**: 在 `KatexRenderer` 中添加了基本的错误处理，以防止渲染错误导致整个应用崩溃。\n3. **性能**: 对于大量 Markdown 内容，考虑使用 `React.memo` 或其他优化技术来提高渲染性能。\n4. **扩展性**: 您可以根据需要添加更多 Marked 扩展，例如支持表格、任务列表等。\n\n通过以上步骤，您就可以在 Next.js 项目中成功集成和使用 OpenWebUI 的 Markdown 和 KaTeX 渲染功能。"
          }
        }
      }
    }
  }
]
